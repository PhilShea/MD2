---
title: "Molecular Dynamics"
output:
  pdf_document: default
  html_notebook: default
---

```{r}
library( parallel)
# Calculate the number of cores
num_cores <- detectCores() - 1
 source("~/DSP/MD/R/runcombine.r")
```


The data was generated by the following Julia script executed on 11 July 2024.  Note that this preceded the correction for non-zero angular momentum, and incorrectly computed the pressure (although this is correctable).

```
include("C:\\Users\\phils\\Documents\\DSP\\MD\\dev\\MD2\\src\\MD2.jl")
using .MD2

cd( "..\\..\\Data\\1980")

pwd()

println("Press Enter to continue:")
readline()

steps = 5000
initsteps = 1000

for t = 1:300
    temp = t/1000
    @show temp
     basename = @sprintf "S1.%.3d" t
     @show basename
     MD2.InitSystem( basename * ".init", temp=temp)
     MD2.RunSystem( basename * ".init", basename * ".1", initsteps)
     @time MD2.RunSystem( basename * ".1", basename * ".2", steps)
     @time MD2.RunSystem( basename * ".2", basename * ".3", steps)
end
```

Get the list of files. Note that the script above named the first run with "init" and the current `RunSystem` Julia function saves the scalars csv file with a space in the filename.  This clumsy choice was fixed using the Microsoft PowerTools PowerRename, where "init" was changed to "0", and the space before "scalars" was removed.  This last change was made in the Julia function `RunSystem`.

```{r}
setwd("H:/Data/DSP/MD/Data/1980")
files = list.files( pattern="*.csv")
length(files)
```
The following will read and plot a file.


```{r}
i <- 40
files[i]
readplot( files[i])
```

The names are now constructed such that it is data series 1 ("S1"), with a set temperature multiplied by 100, and a run number (0, 1, & 2 in this series).  The runs consisted of 1,000 steps after initialization, then two 5,000 step runs.  Since there are 30 of these, we need a means to extract data from the runs automatically.

The 1980 work focused on heating and cooling runs (not yet implemented in the Julia code), and then running for equilibrium, determined by doing a linear regression on the temperature, and declaring success when the correlation coefficient was less than 0.2, and the estimated slope was less than the slope error.

To this criteria we will also examine the total momentum (which should remain small), and the change in total energy (also should be small)

So, we will skip the "0" runs as an initialization run, and work backward from the combined pair of 5,000 step runs, looking for equilibrium.

`combineruns` will combine all the files in a series of runs into one data frame.  The pattern is passed to a `grep` likes function, and the dots must be escaped, and the escape character ("\") must be escaped, so a patter looking for "S1.014.*" looks like "S1\\\\.014\\\\."  

```{r}
x = combineruns(  ".", "S1\\.0014\\.", verbose=TRUE)
plotMD2( x)
```

The momentum is moving around a bit, but that it runs up and back down again is a good sign.  Perhaps more concerning is the change in total energy.  

The database can be created with the following:

```{r}
files2 = Sys.glob( file.path( "S1.*.scalars.csv"))
length(files2)
files2[1:10]
```


```{r}
MD2DF <- createdf(  ".", files, clusters=num_cores)
save(MD2DF,file="MD2DF.S1.Rdata")
```

Now that we have the data, we can plot it.

```{r}
op=  par( mfrow = c(3, 2), mar = c(3, 3, 0.5, 0.5), tcl = -0.3,
        mgp = c(1.7, 0.4, 0) )
plotScalars( MD2DF)
par(op)
```

So something is going on around 0.16.  We can zoom in around here.

```{r}
op=  par( mfrow = c(3, 2), mar = c(3, 3, 0.5, 0.5), tcl = -0.3,
        mgp = c(1.7, 0.4, 0) )
plotScalars( subset( MD2DF, TE.mean< 0.2))
par(op)
```

A few things are apparent here. One, while the initial kinetic energy was increased incrementally, the total energy is not increasing incrementally (note the gaps in the first three plots above).  Two, the relative temperature variance (`rtv`) is pretty high in the first two runs, and also around TE = 0.16, the second near a gap.  Three, the temperature (`ke` in the above) and pressure may have a break around TE = 0.14.

The temperature (really just the kinetic energy, `ke`) and pressure have a clear break, and the total energy cannot be reached between 0.16 and 0.165.  We can see that adding energy between 0.155 and 0.165 is difficult.

The plot below though clearly shows a break where adding energy dow not increase the temperature.

```{r}
 plotconfMD2( x="TE.init", y="ke", df = MD2DF[MD2DF$TE.mean < 0.19,])
  # plot( Pressure.mean ~ TE.mean, data = MD2DF, ...)
```

The potential energy increases in the same region.

```{r}
 plotconfMD2( y="pe", df = MD2DF[MD2DF$TE.mean < 0.19,])
  # plot( Pressure.mean ~ TE.mean, data = MD2DF, ...)
```

Perhaps oddly, the pressure shows a break just like the temperature.  As it turns out, there was an error in the calculation.

```{r}
 plotconfMD2( y="Pressure", df= MD2DF[MD2DF$TE.mean < 0.19,])
  # plot( Pressure.mean ~ TE.mean, data = MD2DF, ...)
```

The following graph shows that the even though the there seemed to be an initial decrease in the total energy in the first several hundred steps, this decrease is small relative to the energy.  The graph below, is like the other graphs, in that it shows the $1\sigma$ confidence region.  While the gap just above 0.16 is suspicious, there are other gaps, and this may just be attributed to the random nature of the initialization.

```{r}
plotconfMD2( df=MD2DF[MD2DF$TE.mean < 0.19,], x="TE.init", y="TE")
```

The pressure should show a break when plotted against temperature, but due to the error, it doesn't.

```{r}
 plotconfMD2( x="ke.mean", y="Pressure", df= MD2DF[MD2DF$TE.mean < 0.19,])
  # plot( Pressure.mean ~ TE.mean, data = MD2DF, ...)
```

Here is the error.  The equation used in S1 was as follows:

$$
  p = \rho \langle k_e \rangle \left( 1 + \frac{ n \langle U_e\rangle}{2 N\langle k_e \rangle}  \right) 
$$
where $\rho$ is the density ($1/\pi$), $n$ is the potential exponent (5), and $\langle k_e \rangle$ and $\langle U_e \rangle$ are the kinetic and potential energy per particle averages, respectively.  These really should be averages over time, not step-by-step like the program calculates them.  Note that the program which created the S1 series used the total kinetic energy ($N k_e$, where $N$ is the number of particles) instead of the per particle energy.  The calculation below will use the averages.

$$
  p = \rho \langle k_e \rangle \left( 1 + \frac{ n \langle U_T\rangle}{2 \langle k_T \rangle}  \right) 
$$

```{r}
pest <- (1/pi) * MD2DF[,"ke.mean"] * 
  ( 1 + (5 * 256* MD2DF[,"pe.mean"]) / (2 * 256 * MD2DF[, "ke.mean"]))
xl <- MD2DF[,"TE.mean"] < 0.2
plot( x=MD2DF[ xl,"ke.mean"], y=pest[xl], xlab="ke", ylab="Pressure")
grid()
points( x=MD2DF[ xl,"ke.mean"], y=MD2DF[ xl,"Pressure.mean"], col='blue')
```

The run with the worst (i.e., the highest) regression coefficient is below:

```{r}
which.max(MD2DF[,"r.squared"])
x = combineruns(  ".", "S1\\.0032\\.")
plotMD2( x)
```

```{r}
i <- 94
files[i]
readplot( files[i])
```
